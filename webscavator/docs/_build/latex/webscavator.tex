% Generated by Sphinx.
\documentclass[letterpaper,10pt,english]{manual}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}


\title{Webscavator Documentation}
\date{August 26, 2010}
\release{0.0.1}
\author{Sarah Lowman}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex
\makemodindex
\newcommand\PYGZat{@}
\newcommand\PYGZlb{[}
\newcommand\PYGZrb{]}
\newcommand\PYGaz[1]{\textcolor[rgb]{0.00,0.63,0.00}{#1}}
\newcommand\PYGax[1]{\textcolor[rgb]{0.84,0.33,0.22}{\textbf{#1}}}
\newcommand\PYGay[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGar[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGas[1]{\textcolor[rgb]{0.25,0.44,0.63}{\textit{#1}}}
\newcommand\PYGap[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGaq[1]{\textcolor[rgb]{0.38,0.68,0.84}{#1}}
\newcommand\PYGav[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGaw[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGat[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGau[1]{\textcolor[rgb]{0.32,0.47,0.09}{#1}}
\newcommand\PYGaj[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGak[1]{\textcolor[rgb]{0.14,0.33,0.53}{#1}}
\newcommand\PYGah[1]{\textcolor[rgb]{0.00,0.13,0.44}{\textbf{#1}}}
\newcommand\PYGai[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGan[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGao[1]{\textcolor[rgb]{0.25,0.44,0.63}{\textbf{#1}}}
\newcommand\PYGal[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGam[1]{\textbf{#1}}
\newcommand\PYGab[1]{\textit{#1}}
\newcommand\PYGac[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaa[1]{\textcolor[rgb]{0.19,0.19,0.19}{#1}}
\newcommand\PYGaf[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGag[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGad[1]{\textcolor[rgb]{0.00,0.25,0.82}{#1}}
\newcommand\PYGae[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaZ[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGbf[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaX[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaY[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGbc[1]{\textcolor[rgb]{0.78,0.36,0.04}{#1}}
\newcommand\PYGbb[1]{\textcolor[rgb]{0.00,0.00,0.50}{\textbf{#1}}}
\newcommand\PYGba[1]{\textcolor[rgb]{0.02,0.16,0.45}{\textbf{#1}}}
\newcommand\PYGaR[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaS[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaP[1]{\textcolor[rgb]{0.05,0.52,0.71}{\textbf{#1}}}
\newcommand\PYGaQ[1]{\textcolor[rgb]{0.78,0.36,0.04}{\textbf{#1}}}
\newcommand\PYGaV[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGaW[1]{\textcolor[rgb]{0.05,0.52,0.71}{\textbf{#1}}}
\newcommand\PYGaT[1]{\textcolor[rgb]{0.73,0.38,0.84}{#1}}
\newcommand\PYGaU[1]{\textcolor[rgb]{0.13,0.50,0.31}{#1}}
\newcommand\PYGaJ[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand\PYGaK[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaH[1]{\textcolor[rgb]{0.50,0.00,0.50}{\textbf{#1}}}
\newcommand\PYGaI[1]{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{#1}}
\newcommand\PYGaN[1]{\textcolor[rgb]{0.73,0.73,0.73}{#1}}
\newcommand\PYGaO[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaL[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand\PYGaM[1]{\colorbox[rgb]{1.00,0.94,0.94}{\textcolor[rgb]{0.25,0.50,0.56}{#1}}}
\newcommand\PYGaB[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGaC[1]{\textcolor[rgb]{0.33,0.33,0.33}{\textbf{#1}}}
\newcommand\PYGaA[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand\PYGaF[1]{\textcolor[rgb]{0.63,0.00,0.00}{#1}}
\newcommand\PYGaG[1]{\textcolor[rgb]{1.00,0.00,0.00}{#1}}
\newcommand\PYGaD[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand\PYGaE[1]{\textcolor[rgb]{0.25,0.50,0.56}{\textit{#1}}}
\newcommand\PYGbg[1]{\textcolor[rgb]{0.44,0.63,0.82}{\textit{#1}}}
\newcommand\PYGbe[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand\PYGbd[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand\PYGbh[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\begin{document}

\maketitle
\tableofcontents




\chapter{Introduction}

This documentation (apart form this page) has been completely auto-generated from the Python code
docstrings, and describes how Webscavator works.

Any TODOs have the following format:

\begin{notice}{note}{Note:}
This is a TODO. Please fix!
\end{notice}


\chapter{Webscavator API}

\resetcurrentobjects
\hypertarget{--doc-launch}{}

\section{launch.py}
\index{launch (module)}
\hypertarget{module-launch}{}
\declaremodule[launch]{}{launch}
\modulesynopsis{}
Copyright (C) 2010 Sarah Lowman

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see \textless{}\href{http://www.gnu.org/licenses/}{http://www.gnu.org/licenses/}\textgreater{}.


\subsection{Starting Webscavator}

To start webscavator:

\begin{Verbatim}[commandchars=@\[\]]
@textgreater[] python launch.py runserver
\end{Verbatim}

Then go to your preferred web browser and go to \href{http://localhost:5000}{http://localhost:5000}
\index{action\_runtests() (in module launch)}

\hypertarget{launch.action_runtests}{}\begin{funcdesc}{action\_runtests}{functional=False, unit=False}
Run tests by first calling \emph{setup()} in \hyperlink{--doc-utils}{\emph{Utils}} and then \emph{runTests(unit, functional)} in 
\hyperlink{--doc-testing}{\emph{Testing}}
\end{funcdesc}
\index{make\_app() (in module launch)}

\hypertarget{launch.make_app}{}\begin{funcdesc}{make\_app}{}
Runs webscavator. First runs \emph{setup()} in \hyperlink{--doc-utils}{\emph{Utils}} 
which loads the configuration file, and 
then runs \emph{make\_app()} in \hyperlink{--doc-application}{\emph{application.py}}.
\end{funcdesc}

\resetcurrentobjects
\hypertarget{--doc-application}{}

\section{application.py}
\index{webscavator.application (module)}
\hypertarget{module-webscavator.application}{}
\declaremodule[webscavator.application]{}{webscavator.application}
\modulesynopsis{}
This file stores the WSGI application class which takes in the URL requested, 
and responds with an html page.
\index{Application (class in webscavator.application)}

\hypertarget{webscavator.application.Application}{}\begin{classdesc}{Application}{}
WSGI Application class. See the 
\href{http://werkzeug.pocoo.org/documentation/dev/tutorial.html}{WerkZeug} 
documentation for more details on how this works.
\index{dispatch() (webscavator.application.Application method)}

\hypertarget{webscavator.application.Application.dispatch}{}\begin{methoddesc}{dispatch}{request, adapter, endpoint, vars}
Dispatch the request to the correct endpoint, i.e. the controller method found in
one of \hyperlink{--doc-controllers}{\emph{Controllers}}
\end{methoddesc}
\index{load\_session() (webscavator.application.Application method)}

\hypertarget{webscavator.application.Application.load_session}{}\begin{methoddesc}{load\_session}{request}
Load cookies from \emph{session\_store} and puts them into \emph{request.session}.
\end{methoddesc}
\index{make\_url\_map() (webscavator.application.Application static method)}

\hypertarget{webscavator.application.Application.make_url_map}{}\begin{staticmethoddesc}{make\_url\_map}{}
Map that defines all the valid URLs and what endpoint they should be dispatched to. 
For example the index page, (which is just \href{http://localhost:5000/}{http://localhost:5000/}) points to
\emph{generalController.index()} in \hyperlink{--doc-generalController}{\emph{generalController}}. The map uses 
\emph{controller\_lookup} dictionary in \hyperlink{--doc-controllers}{\emph{Controllers}}.
\end{staticmethoddesc}
\index{save\_session() (webscavator.application.Application method)}

\hypertarget{webscavator.application.Application.save_session}{}\begin{methoddesc}{save\_session}{request, response}
Save cookies in \emph{session\_store} and \emph{response}.
\end{methoddesc}
\end{classdesc}
\index{make\_app() (in module webscavator.application)}

\hypertarget{webscavator.application.make_app}{}\begin{funcdesc}{make\_app}{}
Make the WGSI application. If \emph{debug} is set to True in the configuration file, 
then an interactive debugger will be 
displayed in the web browser when there are errors. Otherwise a page 500 will be 
displayed.
\end{funcdesc}

\resetcurrentobjects
\hypertarget{--doc-controllers}{}

\section{Controllers}

Package Contents:

\resetcurrentobjects
\hypertarget{--doc-baseController}{}

\subsection{baseController}
\index{webscavator.controllers.baseController (module)}
\hypertarget{module-webscavator.controllers.baseController}{}
\declaremodule[webscavator.controllers.baseController]{}{webscavator.controllers.baseController}
\modulesynopsis{}

\subsubsection{baseController}

Contains the \emph{BaseController} which all other controllers inherit from and a couple of other useful
functions for JSON-ifying responses.
\index{BaseController (class in webscavator.controllers.baseController)}

\hypertarget{webscavator.controllers.baseController.BaseController}{}\begin{classdesc}{BaseController}{request, urls}
\emph{BaseController} contains useful methods for all the controllers, 
contains the return functions and cookie setters/getters.
\index{addDefaultFilters() (webscavator.controllers.baseController.BaseController method)}

\hypertarget{webscavator.controllers.baseController.BaseController.addDefaultFilters}{}\begin{methoddesc}{addDefaultFilters}{}
Adds the default filters for the timegraph such as filtering by browser type,
group, work hours, Google searches and local files. Gets called when a new case
is being set up in \emph{finish\_wizard()} in \hyperlink{--doc-caseController}{\emph{caseController}}.
\end{methoddesc}
\index{defaultResponse() (webscavator.controllers.baseController.BaseController method)}

\hypertarget{webscavator.controllers.baseController.BaseController.defaultResponse}{}\begin{methoddesc}{defaultResponse}{statuscode, *location, **vars}
Return the rendered template with variables with the given \emph{statuscode}.
\end{methoddesc}
\index{renderTemplate() (webscavator.controllers.baseController.BaseController method)}

\hypertarget{webscavator.controllers.baseController.BaseController.renderTemplate}{}\begin{methoddesc}{renderTemplate}{*location, **vars}
Returns a rendered Mako HTML template.
\end{methoddesc}
\index{return404() (webscavator.controllers.baseController.BaseController method)}

\hypertarget{webscavator.controllers.baseController.BaseController.return404}{}\begin{methoddesc}{return404}{}
Calls \emph{defaultResponse} with a 404 page. This method is called by 
\emph{application()} when none of
the entries in the URL map match with any controller endpoints.
\end{methoddesc}
\index{return500() (webscavator.controllers.baseController.BaseController method)}

\hypertarget{webscavator.controllers.baseController.BaseController.return500}{}\begin{methoddesc}{return500}{}
Calls \emph{defaultResponse} with a 500 page. This method is called by 
\emph{application()} when the endpoint
has raised an exception or an error has happened.
\end{methoddesc}
\index{returnResponse() (webscavator.controllers.baseController.BaseController method)}

\hypertarget{webscavator.controllers.baseController.BaseController.returnResponse}{}\begin{methoddesc}{returnResponse}{*location, **vars}
Calls \emph{defaultResponse} with the expected page for the controller endpoint, with
a 200 status code.
\end{methoddesc}
\index{validate\_form() (webscavator.controllers.baseController.BaseController method)}

\hypertarget{webscavator.controllers.baseController.BaseController.validate_form}{}\begin{methoddesc}{validate\_form}{schema}
Validates a form post against schema in \hyperlink{--doc-forms}{\emph{Forms}}.

If no form was posted, returns \emph{False}. 
If the form was posted and it is invalid, returns \emph{False} 
and sets \emph{self.form\_error}, a dictionary with input names and 
their corresponding error messages. 
If the form validated correctly, returns \emph{True} and sets \emph{self.form\_result} to the
validated results.
\end{methoddesc}
\index{write\_log() (webscavator.controllers.baseController.BaseController method)}

\hypertarget{webscavator.controllers.baseController.BaseController.write_log}{}\begin{methoddesc}{write\_log}{dbfile, msg}
Computes a MD5 hash of the dbfile by calling \emph{\_computeHash(file)} and then appends 
the hash in a file for that dbfile by calling \emph{\_storeHash(hash, dbfile, msg)}.
Returns the hash and the path to the folder where the hash file is kept.
\end{methoddesc}
\end{classdesc}
\index{FormState (class in webscavator.controllers.baseController)}

\hypertarget{webscavator.controllers.baseController.FormState}{}\begin{classdesc}{FormState}{obj, case, urls}
Sometimes the validators in \hyperlink{--doc-validators}{\emph{Validators}} need to know stateful information, such as
the current case being edited to compare values with. 
This object is passed to the validators as \emph{state}.
\end{classdesc}
\index{jsonify() (in module webscavator.controllers.baseController)}

\hypertarget{webscavator.controllers.baseController.jsonify}{}\begin{funcdesc}{jsonify}{func}
Wrap a function so the return value is `JSON-ified' and wrapped in a Werkzeug response object. 
This essentially returns something an AJAX request will understand.
\end{funcdesc}
\index{jsonifyfile() (in module webscavator.controllers.baseController)}

\hypertarget{webscavator.controllers.baseController.jsonifyfile}{}\begin{funcdesc}{jsonifyfile}{func}
Similar to \emph{jsonify(func)}, but used for file uploads. 
They have to be put in textareas to work properly.
\end{funcdesc}

\resetcurrentobjects
\hypertarget{--doc-caseController}{}

\subsection{caseController}
\index{webscavator.controllers.caseController (module)}
\hypertarget{module-webscavator.controllers.caseController}{}
\declaremodule[webscavator.controllers.caseController]{}{webscavator.controllers.caseController}
\modulesynopsis{}

\subsubsection{caseController}

Contains the class that has all the endpoints for loading, adding and editing a case.
\index{CaseController (class in webscavator.controllers.caseController)}

\hypertarget{webscavator.controllers.caseController.CaseController}{}\begin{classdesc}{CaseController}{request, urls}
Controller for the set up and editing of cases.
\index{addData() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.addData}{}\begin{methoddesc}{addData}{entry}
Given a validated form called \emph{entry}, adds the group to the database, 
then calls \emph{self.addEntry()} to convert the data in \emph{entry{[}'data'{]}} to \emph{Entry} objects. 
Returns the group if the adding of entries was successful, and otherwise
returns \emph{None}.
\end{methoddesc}
\index{addEntry() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.addEntry}{}\begin{methoddesc}{addEntry}{program, file, group}
Calls the generator \emph{convert\_file()} found in \hyperlink{--doc-converters}{\emph{Converters}} on each row of the file, 
and adds the result to the database. If an exception happens during the converting and
adding of data, then the session is rolled back and \emph{None} is returned. Otherwise
\emph{True} is returned.

\begin{notice}{note}{Note:}
This had been optimised to make the adding of data as fast as possible, but
has been slowed down again by adding search terms.

\textbf{ToDo}: Optimise the adding of search terms.
\end{notice}
\end{methoddesc}
\index{case\_details() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.case_details}{}\begin{methoddesc}{case\_details}{edit=False}
First step of the wizard: add or edit case details.
\end{methoddesc}
\index{check\_details() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.check_details}{}\begin{methoddesc}{check\_details}{edit=False}
Third step of wizard: user gets to check everything has been added correctly.
\end{methoddesc}
\index{edit1() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.edit1}{}\begin{methoddesc}{edit1}{}
Endpoint for editing a case. Returns \emph{self.case\_details(edit=True)}.
\end{methoddesc}
\index{edit2() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.edit2}{}\begin{methoddesc}{edit2}{}
Endpoint for editing CSV files. Returns \emph{self.file\_details(edit=True)}.
\end{methoddesc}
\index{edit3() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.edit3}{}\begin{methoddesc}{edit3}{}
Endpoint for checking details are correct. Returns \emph{self.check\_details(edit=True)}.
\end{methoddesc}
\index{edit4() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.edit4}{}\begin{methoddesc}{edit4}{}
Endpoint for the end of the wizard. Returns \emph{self.finish\_wizard(edit=True)}.
\end{methoddesc}
\index{file\_details() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.file_details}{}\begin{methoddesc}{file\_details}{edit=False}
Second step of wizard: add the browser history files.
\end{methoddesc}
\index{finish\_wizard() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.finish_wizard}{}\begin{methoddesc}{finish\_wizard}{edit=False}
Forth step of wizard: The wizard is complete. Creates a hash of the database
file and adds message to log file by calling \emph{self.write\_log(dbfile, msg)}
found in \hyperlink{--doc-baseController}{\emph{baseController}}.
\end{methoddesc}
\index{jsonAddCase() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.jsonAddCase}{}\begin{methoddesc}{jsonAddCase}{*args, **kwds}
Endpoint for wizard 1 form (adding case name and dbfile name). This is done via Ajax. 
If the form has errors, the error dictionary \emph{self.form\_errors} is jsonified 
and passed back to the webpage and the errors displayed to the user. 
If the form is valid, then the new case is created, the database initialised 
and data saved to the database. This will then return \emph{True}.
\end{methoddesc}
\index{jsonAddEntries() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.jsonAddEntries}{}\begin{methoddesc}{jsonAddEntries}{*args, **kwds}
Endpoint for wizard 2 form (adding CSV/XML data). This is done via Ajax. 
If the form has errors, the error dictionary \emph{self.form\_errors} is jsonified 
and passed back to the webpage and the errors displayed to the user. 
If the form is valid, then \emph{self.addData()} is called. 
If all goes well, this will then return \emph{True}, otherwise if their are errors in 
the adding of the data in \emph{self.addData()} then self.form\_erros is returned.
\end{methoddesc}
\index{jsonEditCase() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.jsonEditCase}{}\begin{methoddesc}{jsonEditCase}{*args, **kwds}
Same as \emph{self.jsonAddCase()} apart from the user is not allowed to edit the database name - 
this can be done manually be renaming the file when not in use.
\end{methoddesc}
\index{jsonEditEntries() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.jsonEditEntries}{}\begin{methoddesc}{jsonEditEntries}{*args, **kwds}
Same as \emph{self.jsonAddEntries} but allows the editing of old entries and the addition
of new entries.
\end{methoddesc}
\index{load() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.load}{}\begin{methoddesc}{load}{**vars}
Endpoint for the page to load an old case.
\end{methoddesc}
\index{loaded() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.loaded}{}\begin{methoddesc}{loaded}{}
Endpoint for when user has chosen to load a particular case. 
Checks whether the case is valid. 
If so, returns \emph{finish\_wizard()}. Otherwise, it returns \emph{self.form\_errors()}.
\end{methoddesc}
\index{wizard() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.wizard}{}\begin{methoddesc}{wizard}{}
Endpoint for the index page when a case is not yet loaded. 
Gives the user a choice whether to add
a new case or load an old case.
\end{methoddesc}
\index{wizard1() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.wizard1}{}\begin{methoddesc}{wizard1}{}
Endpoint for adding a new case. returns \emph{self.case\_details()}.
\end{methoddesc}
\index{wizard2() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.wizard2}{}\begin{methoddesc}{wizard2}{}
Endpoint for adding new CSV files. returns \emph{self.file\_details()}.
\end{methoddesc}
\index{wizard3() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.wizard3}{}\begin{methoddesc}{wizard3}{}
Endpoint for checking details are correct. Returns \emph{self.check\_details()}.
\end{methoddesc}
\index{wizard4() (webscavator.controllers.caseController.CaseController method)}

\hypertarget{webscavator.controllers.caseController.CaseController.wizard4}{}\begin{methoddesc}{wizard4}{}
Endpoint for the end of the wizard. Returns \emph{self.finish\_wizard()}.
\end{methoddesc}
\end{classdesc}

\resetcurrentobjects
\hypertarget{--doc-generalController}{}

\subsection{generalController}
\index{webscavator.controllers.generalController (module)}
\hypertarget{module-webscavator.controllers.generalController}{}
\declaremodule[webscavator.controllers.generalController]{}{webscavator.controllers.generalController}
\modulesynopsis{}

\subsubsection{generalController}

Contains the class for the endpoints of general pages that do not need much complex processing
(apart form the index page).
\index{GeneralController (class in webscavator.controllers.generalController)}

\hypertarget{webscavator.controllers.generalController.GeneralController}{}\begin{classdesc}{GeneralController}{request, urls}
Controller for general pages, e.g. the index page, about page and help pages.
\index{about() (webscavator.controllers.generalController.GeneralController method)}

\hypertarget{webscavator.controllers.generalController.GeneralController.about}{}\begin{methoddesc}{about}{}
Endpoint for the about page.
\end{methoddesc}
\index{guidelines() (webscavator.controllers.generalController.GeneralController method)}

\hypertarget{webscavator.controllers.generalController.GeneralController.guidelines}{}\begin{methoddesc}{guidelines}{}
Endpoint for guidelines on what data to add to cases.
\end{methoddesc}
\index{help() (webscavator.controllers.generalController.GeneralController method)}

\hypertarget{webscavator.controllers.generalController.GeneralController.help}{}\begin{methoddesc}{help}{}
Endpoint for the index help page.
\end{methoddesc}
\index{help\_addfiles() (webscavator.controllers.generalController.GeneralController method)}

\hypertarget{webscavator.controllers.generalController.GeneralController.help_addfiles}{}\begin{methoddesc}{help\_addfiles}{}
Endpoint for the help page on how to add new web history program file convertors
\end{methoddesc}
\index{index() (webscavator.controllers.generalController.GeneralController method)}

\hypertarget{webscavator.controllers.generalController.GeneralController.index}{}\begin{methoddesc}{index}{}
Endpoint for index page of webscavator. If a case has been loaded, this will 
show information about the case and lead onto the visualisations. 
Otherwise, the index page will display a choice
to either load a case or create a new case.
\end{methoddesc}
\index{userguide() (webscavator.controllers.generalController.GeneralController method)}

\hypertarget{webscavator.controllers.generalController.GeneralController.userguide}{}\begin{methoddesc}{userguide}{}
Endpoint for the user documentation.
\end{methoddesc}
\index{userguide\_part1() (webscavator.controllers.generalController.GeneralController method)}

\hypertarget{webscavator.controllers.generalController.GeneralController.userguide_part1}{}\begin{methoddesc}{userguide\_part1}{}
Endpoint for the user documentation on how to extract web history files and add/load/edit a case.
\end{methoddesc}
\index{userguide\_part2() (webscavator.controllers.generalController.GeneralController method)}

\hypertarget{webscavator.controllers.generalController.GeneralController.userguide_part2}{}\begin{methoddesc}{userguide\_part2}{}
Endpoint for the user documentation on how to sue the visualisations.
\end{methoddesc}
\end{classdesc}

\resetcurrentobjects
\hypertarget{--doc-visualController}{}

\subsection{visualController}
\index{webscavator.controllers.visualController (module)}
\hypertarget{module-webscavator.controllers.visualController}{}
\declaremodule[webscavator.controllers.visualController]{}{webscavator.controllers.visualController}
\modulesynopsis{}

\subsubsection{visualController}

Contains the class for the visualisation AJAX endpoints and the add filter form, as 
well as some helper functions.
\index{VisualController (class in webscavator.controllers.visualController)}

\hypertarget{webscavator.controllers.visualController.VisualController}{}\begin{classdesc}{VisualController}{request, urls}
Controller for filter pages and AJAX visualisation calls
\index{addFilter() (webscavator.controllers.visualController.VisualController method)}

\hypertarget{webscavator.controllers.visualController.VisualController.addFilter}{}\begin{methoddesc}{addFilter}{}
Endpoint for the add filter pop-up page.
\end{methoddesc}
\index{jsonAddFilter() (webscavator.controllers.visualController.VisualController method)}

\hypertarget{webscavator.controllers.visualController.VisualController.jsonAddFilter}{}\begin{methoddesc}{jsonAddFilter}{*args, **kwds}
Endpoint for the AJAX request to validate and add a new filter. If valid, the filter
is added and a new hash is created and appended to the database file with the current 
date and time, returning \emph{True}. Otherwise \emph{self.form\_error} is returned.
\end{methoddesc}
\index{jsonGetDomains() (webscavator.controllers.visualController.VisualController method)}

\hypertarget{webscavator.controllers.visualController.VisualController.jsonGetDomains}{}\begin{methoddesc}{jsonGetDomains}{*args, **kwds}
Endpoint for the AJAX request to get the domain names.
Calls \emph{URL.getTop()} in \hyperlink{--doc-models}{\emph{Database Models}} which returns a list of domain name tuples 
in ascending order of number of visits.
\end{methoddesc}
\index{jsonGetEntries() (webscavator.controllers.visualController.VisualController method)}

\hypertarget{webscavator.controllers.visualController.VisualController.jsonGetEntries}{}\begin{methoddesc}{jsonGetEntries}{*args, **kwds}
Endpoint for the AJAX request to get the timegraph. Calls \emph{Case.getTimeGraph()}
in \hyperlink{--doc-models}{\emph{Database Models}} with the date, time and filter options and returns a list of 
dictionaries that Flot can understand to plot. 
The dictionaries are those points to be highlighted, removed and visible.
\end{methoddesc}
\index{jsonGetWordClouds() (webscavator.controllers.visualController.VisualController method)}

\hypertarget{webscavator.controllers.visualController.VisualController.jsonGetWordClouds}{}\begin{methoddesc}{jsonGetWordClouds}{*args, **kwds}
Endpoint for the AJAX request to get the search terms in the word cloud.
Calls \emph{Filter.onlineSearches()} in \hyperlink{--doc-filters}{\emph{Filters}} for each search engine in the config file.
Returns a dictionary of terms.
\end{methoddesc}
\index{processOptions() (webscavator.controllers.visualController.VisualController static method)}

\hypertarget{webscavator.controllers.visualController.VisualController.processOptions}{}\begin{staticmethoddesc}{processOptions}{opts}
Process the options for each filterable table in \hyperlink{--doc-models}{\emph{Database Models}}. 
Returns a dictionary with the table attribute as keys and the operations, 
values and value type as the value tuple.
\end{staticmethoddesc}
\end{classdesc}
\index{convertDates() (in module webscavator.controllers.visualController)}

\hypertarget{webscavator.controllers.visualController.convertDates}{}\begin{funcdesc}{convertDates}{dates}
Given a list of dates in JavaScript date format, returns a list of Python dates.
JavaScript stores dates in milliseconds since the Epoch.
\end{funcdesc}
\index{convertFilters() (in module webscavator.controllers.visualController)}

\hypertarget{webscavator.controllers.visualController.convertFilters}{}\begin{funcdesc}{convertFilters}{request\_args}
For each request argument, if it is a filter, than put it in the appropriate filter list.
The request arguments will either be ``highlight'' or ``remove'' and will subsequently be put
in either \emph{highlight\_funcs} or \emph{remove\_funcs}. Returns those lists.
\end{funcdesc}
\index{convertTimes() (in module webscavator.controllers.visualController)}

\hypertarget{webscavator.controllers.visualController.convertTimes}{}\begin{funcdesc}{convertTimes}{times}
Given a list of times stored as a fraction e.g. 15.5 is 3:30pm, returns a list
of Python times.
\end{funcdesc}
\index{webscavator.controllers (module)}
\hypertarget{module-webscavator.controllers}{}
\declaremodule[webscavator.controllers]{}{webscavator.controllers}
\modulesynopsis{}

\subsection{Controllers}

Controllers control the data between the database model and the html pages. Each controller
inherits from \hyperlink{--doc-baseController}{\emph{baseController}} and consist of endpoints that requests
are dispatched to and helper functions.
\index{controller\_lookup (in module webscavator.controllers)}

\hypertarget{webscavator.controllers.controller_lookup}{}\begin{datadesc}{controller\_lookup}
\emph{controller\_lookup} is a dictionary used by \emph{make\_url\_map()}  in \hyperlink{--doc-application}{\emph{application.py}} to
find the correct endpoints to dispatch the requests to.
Any new controllers should have a line added to this dictionary.
\end{datadesc}

\resetcurrentobjects
\hypertarget{--doc-converters}{}

\section{Converters}

Package Contents:

\resetcurrentobjects
\hypertarget{--doc-xmlConverter}{}

\subsection{xmlConverter}

Children:

\resetcurrentobjects
\hypertarget{--doc-webhistorian}{}

\subsubsection{Web Historian Converter}
\index{webscavator.converters.webhistorian (module)}
\hypertarget{module-webscavator.converters.webhistorian}{}
\declaremodule[webscavator.converters.webhistorian]{}{webscavator.converters.webhistorian}
\modulesynopsis{}\index{WebhistorianConverter (class in webscavator.converters.webhistorian)}

\hypertarget{webscavator.converters.webhistorian.WebhistorianConverter}{}\begin{classdesc}{WebhistorianConverter}{xml\_file}
Converts Web Historian XML output to normalised format. The toplevel element for a web history
entry is \emph{UrlHistoryItem}.
\index{process\_element() (webscavator.converters.webhistorian.WebhistorianConverter method)}

\hypertarget{webscavator.converters.webhistorian.WebhistorianConverter.process_element}{}\begin{methoddesc}{process\_element}{data}
\emph{process\_row} takes in an xml element that contains one web history entry, 
and returns a normalised dictionary as output.
\end{methoddesc}
\end{classdesc}
\index{webscavator.converters.xml\_converter (module)}
\hypertarget{module-webscavator.converters.xml_converter}{}
\declaremodule[webscavator.converters.xmlconverter]{}{webscavator.converters.xml\_converter}
\modulesynopsis{}

\subsubsection{XML Convertors}

Module contains abstract class that all web history programs that output XML data must inherit from.

All children must return in \emph{process\_element(row)}:

\begin{Verbatim}[commandchars=@\[\]]
return {
    'type': type of entry, 
    'url': URL entry, 
    'modified@_time': modified time of entry,
    'access@_time': access time of entry,
    'filename': entry file name, 
    'directory': entry directory,
    'http@_headers': HTTP headers of entry,
    'title': entry page title,
    'deleted': if entry is deleted,
    'content@_type': entry content type,
    'browser@_name': browser used, one of 'Firefox', 'Internet Explorer', 'Safari', 'Chrome', 'Opera',
    'browser@_version': browser version,
    'source@_file': profile or location/name of file
}
\end{Verbatim}

All entries in the dictionary may be \emph{None} apart from \emph{url} and \emph{access\_time}.
\index{XMLConverter (class in webscavator.converters.xml\_converter)}

\hypertarget{webscavator.converters.xml_converter.XMLConverter}{}\begin{classdesc}{XMLConverter}{xml\_file}~\index{process() (webscavator.converters.xml\_converter.XMLConverter method)}

\hypertarget{webscavator.converters.xml_converter.XMLConverter.process}{}\begin{methoddesc}{process}{}
Reads in the XML file. Finds all the top level web history elements and 
returns a generator which can be looped over to get the normalised element entries.
\end{methoddesc}
\end{classdesc}

\resetcurrentobjects
\hypertarget{--doc-csvConverter}{}

\subsection{csvConverter}

Children:

\resetcurrentobjects
\hypertarget{--doc-chromecacheviewer}{}

\subsubsection{Chrome Cache Viewer Converter}
\index{webscavator.converters.chromecacheviewer (module)}
\hypertarget{module-webscavator.converters.chromecacheviewer}{}
\declaremodule[webscavator.converters.chromecacheviewer]{}{webscavator.converters.chromecacheviewer}
\modulesynopsis{}\index{ChromecacheviewerConverter (class in webscavator.converters.chromecacheviewer)}

\hypertarget{webscavator.converters.chromecacheviewer.ChromecacheviewerConverter}{}\begin{classdesc}{ChromecacheviewerConverter}{csv\_file}
Converts Chrome Cache Viewer CSV output to normalised format.

To obtain CSV data from Chrome Cache Viewer, select all the entries, and go to \emph{File \textgreater{}
Save Selected Items}. Save as a \emph{Tab-delimited Text File}, and then change the extension to 
\emph{csv}. Make sure the file is in UTF-8 encoding, otherwise the CSV converter will throw
an exception.
\index{process\_row() (webscavator.converters.chromecacheviewer.ChromecacheviewerConverter method)}

\hypertarget{webscavator.converters.chromecacheviewer.ChromecacheviewerConverter.process_row}{}\begin{methoddesc}{process\_row}{row}
\emph{process\_row} takes in a row from the CSV file, and returns a normalised dictionary as output.

One row of Chrome Cache Viewer's CSV data looks like so:

filename, url, content\_type, file\_size, access\_time, server\_time, modified\_time, expired\_time, 
server\_name, http\_headers, content\_encoding, cache\_name, cache\_control, e\_tag, \_
\end{methoddesc}
\end{classdesc}

\resetcurrentobjects
\hypertarget{--doc-foxanalysis}{}

\subsubsection{Fox Analysis Converter}
\index{webscavator.converters.foxanalysis (module)}
\hypertarget{module-webscavator.converters.foxanalysis}{}
\declaremodule[webscavator.converters.foxanalysis]{}{webscavator.converters.foxanalysis}
\modulesynopsis{}\index{FoxanalysisConverter (class in webscavator.converters.foxanalysis)}

\hypertarget{webscavator.converters.foxanalysis.FoxanalysisConverter}{}\begin{classdesc}{FoxanalysisConverter}{csv\_file}
Converts Fox Analysis CSV output to normalised format.

To obtain CSV data from Fox Analysis click on \emph{File \textgreater{} Export to \textgreater{} CSV File}. Please load in 
the \emph{Website.csv} file produced.

This is comma delimited by default and has 1 line at the top for titles and headers.
\index{process\_row() (webscavator.converters.foxanalysis.FoxanalysisConverter method)}

\hypertarget{webscavator.converters.foxanalysis.FoxanalysisConverter.process_row}{}\begin{methoddesc}{process\_row}{row}
\emph{process\_row} takes in a row from the CSV file, and returns a normalised dictionary as output.

One row of Fox Analysis CSV data looks like so:

id, fromvisit, datevisited, url, host, totalvisitcount, type, frecency, title
\end{methoddesc}
\end{classdesc}

\resetcurrentobjects
\hypertarget{--doc-pasco}{}

\subsubsection{Pasco Converter}
\index{webscavator.converters.pasco (module)}
\hypertarget{module-webscavator.converters.pasco}{}
\declaremodule[webscavator.converters.pasco]{}{webscavator.converters.pasco}
\modulesynopsis{}\index{PascoConverter (class in webscavator.converters.pasco)}

\hypertarget{webscavator.converters.pasco.PascoConverter}{}\begin{classdesc}{PascoConverter}{csv\_file}
Converts Pasco CSV output to normalised format.

To obtain CSV data from Pasco run:

\begin{Verbatim}[commandchars=@\[\]]
pasco index.dat @textgreater[] output.csv
\end{Verbatim}

This is tab delimited by default and has 3 lines at the top for titles and headers.
\index{process\_row() (webscavator.converters.pasco.PascoConverter method)}

\hypertarget{webscavator.converters.pasco.PascoConverter.process_row}{}\begin{methoddesc}{process\_row}{row}
\emph{process\_row} takes in a row from the CSV file, and returns a normalised dictionary as output.

One row of Pasco CSV data looks like so:

type, url, modified\_time, access\_time, filename, directory, http\_headers
\end{methoddesc}
\end{classdesc}

\resetcurrentobjects
\hypertarget{--doc-netanalysis}{}

\subsubsection{Net Analysis Converter}
\index{webscavator.converters.netanalysis (module)}
\hypertarget{module-webscavator.converters.netanalysis}{}
\declaremodule[webscavator.converters.netanalysis]{}{webscavator.converters.netanalysis}
\modulesynopsis{}\index{NetanalysisConverter (class in webscavator.converters.netanalysis)}

\hypertarget{webscavator.converters.netanalysis.NetanalysisConverter}{}\begin{classdesc}{NetanalysisConverter}{csv\_file}
Converts Net Analysis CSV output to normalised format.

To obtain CSV data from Net Analysis, click on \emph{File \textgreater{} Export History As \textgreater{} Tab Delimited Text}.
Rename the extension to \emph{csv} instead of \emph{txt}.
\index{process\_row() (webscavator.converters.netanalysis.NetanalysisConverter method)}

\hypertarget{webscavator.converters.netanalysis.NetanalysisConverter.process_row}{}\begin{methoddesc}{process\_row}{row}~\begin{quote}

\emph{process\_row} takes in a row from the CSV file, and returns a normalised dictionary as output.

Net Analysis produces the same output regardless of what type of browser was used, 
producing \emph{a lot} of columns to process. One row of Fox Analysis CSV data looks like so:
\end{quote}

type, tag, last\_visited\_utc, access\_time, hits, user, url, host, title, abs\_path, query, 
fragment, port, url\_category, username, password, redirect\_url, feed\_url, referral\_url, 
favicon\_url, cache\_folder, cache\_file, extension, length, exists, http\_response, 
cache\_entry\_type\_flag, content\_type, content\_length, content\_encoding, active\_bias, 
date\_first\_visited, date\_expiration, modified\_time, date\_index\_created, date\_added, 
date\_last\_sync, source\_file, source\_offset, index\_type, browser\_version, ie\_type, status, 
bookmark, urn

\begin{notice}{note}{Note:}
Net Analysis allows users to move columns around and export the data in it's new format.
Currently this convertor assumes the columns are in the correct format and does not
work when they are moved / there are less columns.

\textbf{ToDo}: See if there is a work around for this.
\end{notice}
\end{methoddesc}
\end{classdesc}
\index{webscavator.converters.csv\_converter (module)}
\hypertarget{module-webscavator.converters.csv_converter}{}
\declaremodule[webscavator.converters.csvconverter]{}{webscavator.converters.csv\_converter}
\modulesynopsis{}

\subsubsection{CSV Converters}

Module contains abstract class that all web history programs that output CSV data must inherit from.

All children must return in \emph{process\_row(row)}:

\begin{Verbatim}[commandchars=@\[\]]
return {
    'type': type of entry, 
    'url': URL entry, 
    'modified@_time': modified time of entry,
    'access@_time': access time of entry,
    'filename': entry file name, 
    'directory': entry directory,
    'http@_headers': HTTP headers of entry,
    'title': entry page title,
    'deleted': if entry is deleted,
    'content@_type': entry content type,
    'browser@_name': browser used, one of 'Firefox', 'Internet Explorer', 'Safari', 'Chrome', 'Opera',
    'browser@_version': browser version,
    'source@_file': profile or location/name of file
}
\end{Verbatim}

All entries in the dictionary may be \emph{None} apart from \emph{url} and \emph{access\_time}.
\index{CSVConverter (class in webscavator.converters.csv\_converter)}

\hypertarget{webscavator.converters.csv_converter.CSVConverter}{}\begin{classdesc}{CSVConverter}{csv\_file}
Children classes must override delimiter and skip:
\begin{description}
\item[\emph{delimiter}]
the CSV file delimiter.

\item[\emph{skip}]
how many lines to skip at the top of the CSV file (including header lines).

\end{description}
\index{process() (webscavator.converters.csv\_converter.CSVConverter method)}

\hypertarget{webscavator.converters.csv_converter.CSVConverter.process}{}\begin{methoddesc}{process}{}
Reads in the CSV file, skips \emph{skip} number of lines and then for each line in the CSV file calls
\emph{self.process\_row()} in the child class.

Returns a generator which can be looped over to get the normalised row.
\end{methoddesc}
\end{classdesc}
\index{webscavator.converters (module)}
\hypertarget{module-webscavator.converters}{}
\declaremodule[webscavator.converters]{}{webscavator.converters}
\modulesynopsis{}

\subsection{Converters}

All the modules in this package represent a particular web history program which gives an output such 
as a CSV file, XML file or text file.

Each module takes in a row from the output and returns a particular dictionary which is used to add 
that row to the webscavator database. see \hyperlink{--doc-csvConverter}{\emph{csvConverter}} for details of adding CSV data
and \hyperlink{--doc-xmlConverter}{\emph{xmlConverter}} for details of adding XML data.


\subsection{Variables}

\emph{program\_lookup} is a dictionary of all the currently supported programs: key = Program long name 
and value is name the short name stored in the database. \emph{program\_lookup} is accessed through the 
methods below.

\emph{program\_info} is a dictionary of useful information for each of the programs supported.
The minimum entries for each dictionary should be \emph{image} - what icon is associated with
the program (default is application.png) and \emph{description} - how to produce a valid 
file form the program (use HTML). Other entries can be added and used when needed. 
\emph{program\_info} is also accessed through the methods below.

Add to these two dictionaries when adding a new program converter.


\subsection{Functions}
\index{convert\_file() (in module webscavator.converters)}

\hypertarget{webscavator.converters.convert_file}{}\begin{funcdesc}{convert\_file}{type, file}
Given a file, locates the correct converter and returns a generator which produces 
a normalised dictionary of data for each row in the file.
\end{funcdesc}
\index{get\_file() (in module webscavator.converters)}

\hypertarget{webscavator.converters.get_file}{}\begin{funcdesc}{get\_file}{name}
Given a full name, return the file type.
\end{funcdesc}
\index{get\_name() (in module webscavator.converters)}

\hypertarget{webscavator.converters.get_name}{}\begin{funcdesc}{get\_name}{id}
Given the name of the python file the converter is stored in, 
return the full name of the converter.
\end{funcdesc}
\index{get\_names() (in module webscavator.converters)}

\hypertarget{webscavator.converters.get_names}{}\begin{funcdesc}{get\_names}{}
Return a list of all the full names of the converters.
\end{funcdesc}
\index{get\_program() (in module webscavator.converters)}

\hypertarget{webscavator.converters.get_program}{}\begin{funcdesc}{get\_program}{name}
Given a full name, return the python file name.
\end{funcdesc}
\index{get\_program\_info() (in module webscavator.converters)}

\hypertarget{webscavator.converters.get_program_info}{}\begin{funcdesc}{get\_program\_info}{program}
Given a program name, return the dictionary of information about it.
\end{funcdesc}
\index{get\_program\_infos() (in module webscavator.converters)}

\hypertarget{webscavator.converters.get_program_infos}{}\begin{funcdesc}{get\_program\_infos}{}
Return the dictionary program\_info with information about each of the supported programs.
\end{funcdesc}
\index{get\_programs\_files() (in module webscavator.converters)}

\hypertarget{webscavator.converters.get_programs_files}{}\begin{funcdesc}{get\_programs\_files}{}
Return a list of (full name, file type) tuples
\end{funcdesc}

\resetcurrentobjects
\hypertarget{--doc-inputs}{}

\section{Forms and Validators}

Package Contents:

\resetcurrentobjects
\hypertarget{--doc-forms}{}

\subsection{Forms}
\index{webscavator.forms.forms (module)}
\hypertarget{module-webscavator.forms.forms}{}
\declaremodule[webscavator.forms.forms]{}{webscavator.forms.forms}
\modulesynopsis{}
Each class represents the fields present on a particular web form, and how it should be validated.
Specific validators can be found in \hyperlink{--doc-validators}{\emph{Validators}}. All forms inherit from Schema.

If the form has an error, the validator will throw an exception and add the name of the 
form field and the error message to a dictionary \emph{form\_error}, which is passed back to the 
web page for the user to correct. If the form is valid, the endpoint will process the form, 
and return the successful web page.

\begin{notice}{note}{Note:}
Most of these forms were created before it was realised that files other than CSV were needed
(such as XML). 
Therefore a lot of form field names are `csv\_file' rather than just generic `file'.

\textbf{ToDo}: Change any field names that refer to csv data to be more generic. Applies to Mako
templates too.
\end{notice}
\index{AddData (class in webscavator.forms.forms)}

\hypertarget{webscavator.forms.forms.AddData}{}\begin{classdesc}{AddData}{*args, **kw}
Form to add a new file. Inherits from \emph{Data()}

\textbf{Attributes}

\emph{program} -- web history program used to create file.

\emph{name} -- name of this dataset.

\emph{desc} -- optional description of dataset.

\emph{data} -- the web history file.

\textbf{Messages}
\begin{description}
\item[\code{badDictType}:]
The input must be dict-like (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{missingValue}:]
Missing value

\item[\code{noneType}:]
The input must be a string (not None)

\item[\code{notExpected}:]
The input field \code{\%(name)s} was not expected.

\end{description}
\end{classdesc}
\index{Case (class in webscavator.forms.forms)}

\hypertarget{webscavator.forms.forms.Case}{}\begin{classdesc}{Case}{*args, **kw}
Case Schema.

\textbf{Messages}
\begin{description}
\item[\code{badDictType}:]
The input must be dict-like (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{missingValue}:]
Missing value

\item[\code{noneType}:]
The input must be a string (not None)

\item[\code{notExpected}:]
The input field \code{\%(name)s} was not expected.

\end{description}
\end{classdesc}
\index{Data (class in webscavator.forms.forms)}

\hypertarget{webscavator.forms.forms.Data}{}\begin{classdesc}{Data}{*args, **kw}
Data Schema.

\textbf{Messages}
\begin{description}
\item[\code{badDictType}:]
The input must be dict-like (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{missingValue}:]
Missing value

\item[\code{noneType}:]
The input must be a string (not None)

\item[\code{notExpected}:]
The input field \code{\%(name)s} was not expected.

\end{description}
\end{classdesc}
\index{EditData (class in webscavator.forms.forms)}

\hypertarget{webscavator.forms.forms.EditData}{}\begin{classdesc}{EditData}{*args, **kw}
Form to edit file. Inherits from \emph{Data()}

\textbf{Attributes}

\emph{group} -- the current data group being edited. Validator checks this exists.

\emph{program} -- web history program used to create file.

\emph{name} -- name of this data.

\emph{desc} -- optional description of data.

\emph{keepcsv} -- user chooses to keep the current file or upload another.

\emph{data} -- the new file if keepcsv is \emph{False}.

\textbf{Messages}
\begin{description}
\item[\code{badDictType}:]
The input must be dict-like (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{missingValue}:]
Missing value

\item[\code{noneType}:]
The input must be a string (not None)

\item[\code{notExpected}:]
The input field \code{\%(name)s} was not expected.

\end{description}
\end{classdesc}
\index{Filter (class in webscavator.forms.forms)}

\hypertarget{webscavator.forms.forms.Filter}{}\begin{classdesc}{Filter}{*args, **kw}
Represents one filter line. \emph{add\_filter\_form} can have many filter lines.

\textbf{Attributes}

\emph{cls} -- The Class the filter applies to.

\emph{attribute} -- the Class's attribute the filter applies to.

\emph{function} -- the operation to do on the attribute.

\emph{value} -- the value the attribute will be compared with.

\emph{value\_list} -- the file of items to compare the attribute to.

Either \emph{value} or \emph{value\_list} will be selected, the other will be \emph{None}.

\textbf{Messages}
\begin{description}
\item[\code{badDictType}:]
The input must be dict-like (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{missingValue}:]
Missing value

\item[\code{noneType}:]
The input must be a string (not None)

\item[\code{notExpected}:]
The input field \code{\%(name)s} was not expected.

\end{description}
\end{classdesc}
\index{add\_filter\_form (class in webscavator.forms.forms)}

\hypertarget{webscavator.forms.forms.add_filter_form}{}\begin{classdesc}{add\_filter\_form}{*args, **kw}
Form to add a filter.

\textbf{Attributes}

\emph{filter} -- list of \emph{Filter()}.

\emph{name} -- name of the filter.

\textbf{Messages}
\begin{description}
\item[\code{badDictType}:]
The input must be dict-like (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{missingValue}:]
Missing value

\item[\code{noneType}:]
The input must be a string (not None)

\item[\code{notExpected}:]
The input field \code{\%(name)s} was not expected.

\end{description}
\end{classdesc}
\index{edit1\_form (class in webscavator.forms.forms)}

\hypertarget{webscavator.forms.forms.edit1_form}{}\begin{classdesc}{edit1\_form}{*args, **kw}
Form to edit case. Inherits from \emph{Case()}

\textbf{Attributes}

\emph{name} -- new name of case.

\textbf{Messages}
\begin{description}
\item[\code{badDictType}:]
The input must be dict-like (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{missingValue}:]
Missing value

\item[\code{noneType}:]
The input must be a string (not None)

\item[\code{notExpected}:]
The input field \code{\%(name)s} was not expected.

\end{description}
\end{classdesc}
\index{edit2\_form (class in webscavator.forms.forms)}

\hypertarget{webscavator.forms.forms.edit2_form}{}\begin{classdesc}{edit2\_form}{*args, **kw}
Form to edit multiple files.

\textbf{Attributes}

\emph{csv\_entry} -- list of \emph{EditData} objects.

\textbf{Messages}
\begin{description}
\item[\code{badDictType}:]
The input must be dict-like (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{missingValue}:]
Missing value

\item[\code{noneType}:]
The input must be a string (not None)

\item[\code{notExpected}:]
The input field \code{\%(name)s} was not expected.

\end{description}
\end{classdesc}
\index{load\_form (class in webscavator.forms.forms)}

\hypertarget{webscavator.forms.forms.load_form}{}\begin{classdesc}{load\_form}{*args, **kw}
Form to load a case Sqlite database file.

\textbf{Attributes}

\emph{case} -- the name of a case. Validator checks case exists on disk.

\textbf{Messages}
\begin{description}
\item[\code{badDictType}:]
The input must be dict-like (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{missingValue}:]
Missing value

\item[\code{noneType}:]
The input must be a string (not None)

\item[\code{notExpected}:]
The input field \code{\%(name)s} was not expected.

\end{description}
\end{classdesc}
\index{wizard1\_form (class in webscavator.forms.forms)}

\hypertarget{webscavator.forms.forms.wizard1_form}{}\begin{classdesc}{wizard1\_form}{*args, **kw}
Form to add a new case. Inherits from \emph{Case()}.

\textbf{Attributes}

\emph{name} -- name of case.

\emph{dbfile} -- file to save case to. Validator checks this file doesn't already exist.

\textbf{Messages}
\begin{description}
\item[\code{badDictType}:]
The input must be dict-like (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{missingValue}:]
Missing value

\item[\code{noneType}:]
The input must be a string (not None)

\item[\code{notExpected}:]
The input field \code{\%(name)s} was not expected.

\end{description}
\end{classdesc}
\index{wizard2\_form (class in webscavator.forms.forms)}

\hypertarget{webscavator.forms.forms.wizard2_form}{}\begin{classdesc}{wizard2\_form}{*args, **kw}
Form to add multiple files.

\textbf{Attributes}

\emph{csv\_entry} -- list of \emph{AddData} objects.

\textbf{Messages}
\begin{description}
\item[\code{badDictType}:]
The input must be dict-like (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{missingValue}:]
Missing value

\item[\code{noneType}:]
The input must be a string (not None)

\item[\code{notExpected}:]
The input field \code{\%(name)s} was not expected.

\end{description}
\end{classdesc}

\resetcurrentobjects
\hypertarget{--doc-validators}{}

\subsection{Validators}
\index{webscavator.forms.validators (module)}
\hypertarget{module-webscavator.forms.validators}{}
\declaremodule[webscavator.forms.validators]{}{webscavator.forms.validators}
\modulesynopsis{}
Each class validates a certain field or group of fields within a form.

If the field(s) have errors, the validator will throw an \emph{Invalid} exception and add the 
name of the form field and the error message to a dictionary, which is passed back to the 
web page for the user to correct.

If the field is valid, the validator will return the value. 
The validators may also process the value
and return the processed value, e.g. the value is a Case id, and the processor returns the 
Case object.

\begin{notice}{note}{Note:}
Most of these forms were created before it was realised that files other than CSV were needed
(such as XML). 
Therefore a lot of form field names are `csv\_file' rather than just generic `file'. Also, since
XML (and any other added convertor) files are allowed, the uploaded file is no longer checked
to see if it ends with CSV. This should be fixed to check against the type of file it expects.

\textbf{ToDo}: Change any field names that refer to csv data to be more generic. Applies to Mako
templates too.

\textbf{ToDo}: Validate the uploaded data against what it should be. E.g Webscavator = XML and 
Net Analysis = CSV. PErhaps add a column to \emph{program\_lookup} or \emph{program\_info} in 
\hyperlink{--doc-converters}{\emph{Converters}}.

\textbf{ToDo}: Add more checks for duplication, e.g. not allowing groups or filters with same name.
\end{notice}
\index{CheckAllowed (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.CheckAllowed}{}\begin{classdesc}{CheckAllowed}{*args, **kw}
Check the value is within a set of predefined values.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{CheckAllowedAttributes (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.CheckAllowedAttributes}{}\begin{classdesc}{CheckAllowedAttributes}{*args, **kw}
Checks that the attribute belongs to the class in the same filter.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{CheckAllowedClass (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.CheckAllowedClass}{}\begin{classdesc}{CheckAllowedClass}{*args, **kw}
Checks to see if the class is one of a predefined set of allowed classes.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{invalid}:]
You have chosen an invalid selection

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{CheckAllowedFunctions (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.CheckAllowedFunctions}{}\begin{classdesc}{CheckAllowedFunctions}{*args, **kw}
Checks that the operation is allowed on the attribute in the same filter.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{CheckAllowedProgram (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.CheckAllowedProgram}{}\begin{classdesc}{CheckAllowedProgram}{*args, **kw}
Checks that the web history program selected is within a set of predefined programs.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{invalid}:]
You have chosen an invalid program

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{CheckAllowedValues (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.CheckAllowedValues}{}\begin{classdesc}{CheckAllowedValues}{*args, **kw}
Checks that the value is allowed for the attribute in the same filter.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{CheckCaseDoesntExist (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.CheckCaseDoesntExist}{}\begin{classdesc}{CheckCaseDoesntExist}{*args, **kw}
Checks that case database files do not already exist on disk.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{duplication}:]
This database file has already been used

\item[\code{empty}:]
Please enter a value

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{CheckCaseExists (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.CheckCaseExists}{}\begin{classdesc}{CheckCaseExists}{*args, **kw}
Checks that case database files does exist.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{invalid}:]
You have chosen a case that does not exist

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{CheckHasItems (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.CheckHasItems}{}\begin{classdesc}{CheckHasItems}{*args, **kw}
Checks the value is not empty / \emph{None} / \emph{false} etc.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{invalid}:]
Please select an item.

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{File (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.File}{}\begin{classdesc}{File}{*args, **kw}
Checks whether an uploaded file is empty or not.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{GroupInDatabase (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.GroupInDatabase}{}\begin{classdesc}{GroupInDatabase}{*args, **kw}
Checks that when editing a group of data, that the group is the correct one.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{invalid}:]
An invalid id for these web browser files has been given

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{NoDuplicates (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.NoDuplicates}{}\begin{classdesc}{NoDuplicates}{*args, **kw}
Checks there are no duplicates in the inputed list.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{invalid}:]
You selected the same value more than once.

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{NonAscii (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.NonAscii}{}\begin{classdesc}{NonAscii}{*args, **kw}
Checks value is alpha numeric.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{invalid}:]
Please remove any spaces and non ASCII characters.

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{NotInDatabase (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.NotInDatabase}{}\begin{classdesc}{NotInDatabase}{*args, **kw}
Checks the data supplied is not already in database when adding a new object. 
If editing an object, then it will already be in the database, so must supply 
\emph{currentObj} in \emph{state}. If they match then allowed.

\emph{state} is a \emph{FormState} object which is populated in \emph{validate\_form} in
\hyperlink{--doc-baseController}{\emph{baseController}}.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{duplication}:]
This has already been used

\item[\code{empty}:]
Please enter a value

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\index{valueNotAllowed() (webscavator.forms.validators.NotInDatabase method)}

\hypertarget{webscavator.forms.validators.NotInDatabase.valueNotAllowed}{}\begin{methoddesc}{valueNotAllowed}{obj}
Override to check if values are not in a list of disallowed values.
\end{methoddesc}
\end{classdesc}
\index{RemoveEmpties (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.RemoveEmpties}{}\begin{classdesc}{RemoveEmpties}{*args, **kw}
Removes empty items from a list.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{RequireIfCondition (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.RequireIfCondition}{}\begin{classdesc}{RequireIfCondition}{*args, **kw}
\emph{RequireIfCondition} requires `requireds' fields if `field' {[}condition{]} `value'. {[}condition{]} is 
defined by \emph{RequireIfCondition}`s children as can be equals or not equals.

E.g. if a user selects the option `other' in a select box, then it is required that they
fill in a value in a text input called `Other'.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{RequireIfEquals (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.RequireIfEquals}{}\begin{classdesc}{RequireIfEquals}{*args, **kw}
Child of \emph{RequireIfCondition}, the condition is \emph{==}

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\index{condition() (webscavator.forms.validators.RequireIfEquals method)}

\hypertarget{webscavator.forms.validators.RequireIfEquals.condition}{}\begin{methoddesc}{condition}{}
eq(a, b) -- Same as a==b.
\end{methoddesc}
\end{classdesc}
\index{RequireIfNotEquals (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.RequireIfNotEquals}{}\begin{classdesc}{RequireIfNotEquals}{*args, **kw}
Child of \emph{RequireIfCondition}, the condition is \emph{!=}

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\index{condition() (webscavator.forms.validators.RequireIfNotEquals method)}

\hypertarget{webscavator.forms.validators.RequireIfNotEquals.condition}{}\begin{methoddesc}{condition}{}
ne(a, b) -- Same as a!=b.
\end{methoddesc}
\end{classdesc}
\index{StringNone (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.StringNone}{}\begin{classdesc}{StringNone}{*args, **kw}
Checks to see if value has a string value `None', if so, convert this to a Python
\emph{None}.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{invalid}:]
The text you have entered is invalid

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{Upload (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.Upload}{}\begin{classdesc}{Upload}{*args, **kw}
Upload a file. The value returned is the file stream.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{UploadData (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.UploadData}{}\begin{classdesc}{UploadData}{*args, **kw}
Checks the file uploaded is a CSV file.

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{invalid}:]
You did not upload a CSV file

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{ValidCSVData (class in webscavator.forms.validators)}

\hypertarget{webscavator.forms.validators.ValidCSVData}{}\begin{classdesc}{ValidCSVData}{*args, **kw}
Checks that the data in a CSV file can be processed correctly

\textbf{Messages}
\begin{description}
\item[\code{badType}:]
The input must be a string (not a \code{\%(type)s}: \code{\%(value)r})

\item[\code{empty}:]
Please enter a value

\item[\code{noneType}:]
The input must be a string (not None)

\end{description}
\end{classdesc}
\index{webscavator.forms (module)}
\hypertarget{module-webscavator.forms}{}
\declaremodule[webscavator.forms]{}{webscavator.forms}
\modulesynopsis{}

\subsection{Forms and Validators}

Forms and Validators use the \href{http://formencode.org/}{FormEncode library}.

Every HTML form in Webscavator is validated using \hyperlink{--doc-forms}{\emph{Forms}} and \hyperlink{--doc-validators}{\emph{Validators}}. Form
data is kept in \emph{self.request.form}, e.g.:

\begin{Verbatim}[commandchars=@\[\]]
request@PYGbe[.]form@PYGZlb[]@PYGaB[']@PYGaB[date]@PYGaB[']@PYGZrb[] @PYGbe[=] @PYGaB[']@PYGaB[1/1/2010]@PYGaB[']
\end{Verbatim}

Each endpoint that wants to validate a form 
calls \emph{self.validate\_form(schema)} defined in \hyperlink{--doc-baseController}{\emph{baseController}}, where \emph{schema} is one of the 
classes in \hyperlink{--doc-forms}{\emph{Forms}}.

The data is validated according to the schemas validators, most
of which come from FormEncode, but others are defined in \hyperlink{--doc-validators}{\emph{Validators}}. If there is an error,
the validator will raise an exception which gets stored in \emph{self.form\_errors}, a dictionary
of form names and their error messages, e.g.:

\begin{Verbatim}[commandchars=@\[\]]
form@_errors@PYGZlb[]@PYGaB[']@PYGaB[date]@PYGaB[']@PYGZrb[] @PYGbe[=] @PYGaB["]@PYGaB[The date must be in dd/mm/yyyy format.]@PYGaB["]
\end{Verbatim}

If there are no errors, \emph{self.form\_result} gets populated with the validated results, e.g.:

\begin{Verbatim}[commandchars=@\[\]]
form@_result@PYGZlb[]@PYGaB[']@PYGaB[date]@PYGaB[']@PYGZrb[] @PYGbe[=] datetime(@PYGaw[2010], @PYGaw[1], @PYGaw[1])
\end{Verbatim}

\resetcurrentobjects
\hypertarget{--doc-model}{}

\section{Models}

Package Contents:

\resetcurrentobjects
\hypertarget{--doc-models}{}

\subsection{Database Models}
\index{webscavator.model.models (module)}
\hypertarget{module-webscavator.model.models}{}
\declaremodule[webscavator.model.models]{}{webscavator.model.models}
\modulesynopsis{}

\subsubsection{Models}

This is where all the database models are defined. 
Each database table is represented by a class, and each object in that class is a table row. 
SQLAlchemy converts the objects into rows and any manipulation on them as SQL queries 
to abstract the model from the actual database implementation used.
\index{Browser (class in webscavator.model.models)}

\hypertarget{webscavator.model.models.Browser}{}\begin{classdesc}{Browser}{name, version, source}
Class that stores browser types.
\begin{description}
\item[\emph{id}]
browser id

\item[\emph{name}]
browser name

\item[\emph{version}]
browser version

\item[\emph{source}]
browser source. this is either a profile for Firefox/Chrome 
or the file location for IE, e.g. history or cache

\item[\emph{entries}]
list of entry items that were made using this browser

\end{description}
\index{getPercentages() (webscavator.model.models.Browser static method)}

\hypertarget{webscavator.model.models.Browser.getPercentages}{}\begin{staticmethoddesc}{getPercentages}{}
Used in the overview statistics. Returns a list of \emph{(browser object, percent)} tuples 
for each browser where percent is the percentage this browser is used in all the entries.
\end{staticmethoddesc}
\index{id (webscavator.model.models.Browser attribute)}

\hypertarget{webscavator.model.models.Browser.id}{}\begin{memberdesc}{id}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{name (webscavator.model.models.Browser attribute)}

\hypertarget{webscavator.model.models.Browser.name}{}\begin{memberdesc}{name}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{source (webscavator.model.models.Browser attribute)}

\hypertarget{webscavator.model.models.Browser.source}{}\begin{memberdesc}{source}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{version (webscavator.model.models.Browser attribute)}

\hypertarget{webscavator.model.models.Browser.version}{}\begin{memberdesc}{version}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\end{classdesc}
\index{Case (class in webscavator.model.models)}

\hypertarget{webscavator.model.models.Case}{}\begin{classdesc}{Case}{name}
Class that stores the case. Each database will only have one case.
\begin{description}
\item[\emph{id}    ]
case id

\item[\emph{name}]
case name

\item[\emph{date}]
date this case was created

\item[\emph{groups}]
A list of group objects that belong to this case

\end{description}
\index{create\_database() (webscavator.model.models.Case static method)}

\hypertarget{webscavator.model.models.Case.create_database}{}\begin{staticmethoddesc}{create\_database}{dbfile}
Creates the database file, initialises all the models in this file and binds the 
database to webscavator's session.
\end{staticmethoddesc}
\index{date (webscavator.model.models.Case attribute)}

\hypertarget{webscavator.model.models.Case.date}{}\begin{memberdesc}{date}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{dblocation() (webscavator.model.models.Case method)}

\hypertarget{webscavator.model.models.Case.dblocation}{}\begin{methoddesc}{dblocation}{dbfile}
Return the absolute location of a given database file.
\end{methoddesc}
\index{filter\_queries() (webscavator.model.models.Case static method)}

\hypertarget{webscavator.model.models.Case.filter_queries}{}\begin{staticmethoddesc}{filter\_queries}{q, remove\_funcs, highlight\_funcs}
This expects \emph{q} to have entry, browser, url, group and search\_terms available 
for filtering. Returns three queries with the correct entries put in each according
to the filters:
\emph{q\_removed}, \emph{q\_highlighted} and \emph{q\_not\_highlighted}.
\end{staticmethoddesc}
\index{formatted\_date (webscavator.model.models.Case attribute)}

\hypertarget{webscavator.model.models.Case.formatted_date}{}\begin{memberdesc}{formatted\_date}
A property for formatted\_date. Returns the date in a normalised format.
\end{memberdesc}
\index{getAllEntries() (webscavator.model.models.Case static method)}

\hypertarget{webscavator.model.models.Case.getAllEntries}{}\begin{staticmethoddesc}{getAllEntries}{case}
Returns all the entries for this case where the access time and date are not \emph{None}.
\end{staticmethoddesc}
\index{getMinMax() (webscavator.model.models.Case static method)}

\hypertarget{webscavator.model.models.Case.getMinMax}{}\begin{staticmethoddesc}{getMinMax}{latest, case}
Return the minimum and maximum dates for Flot. Given a date, returns minimum which is
1 month prior on the 1st of the month, to the last day of the month for the given date.
E.g. given 12th May, returns (1st April, 31st May). This is returned in JavaScript 
milliseconds since the Epoch.
\end{staticmethoddesc}
\index{getNewestEntry() (webscavator.model.models.Case static method)}

\hypertarget{webscavator.model.models.Case.getNewestEntry}{}\begin{staticmethoddesc}{getNewestEntry}{case}
Returns the latest Entry for this case.
\end{staticmethoddesc}
\index{getOldestEntry() (webscavator.model.models.Case static method)}

\hypertarget{webscavator.model.models.Case.getOldestEntry}{}\begin{staticmethoddesc}{getOldestEntry}{case}
Returns the oldest Entry for this case.
\end{staticmethoddesc}
\index{getTimeGraph() (webscavator.model.models.Case static method)}

\hypertarget{webscavator.model.models.Case.getTimeGraph}{}\begin{staticmethoddesc}{getTimeGraph}{startdate, enddate, starttime, endtime, case, remove\_funcs, highlight\_funcs, remove\_duplicates=False, duplicate\_time=0}
Given a start and end date and time and filters, returns three lists of entry points:
\emph{highlighted}, \emph{not\_highlighted} and \emph{removed} by calling \emph{filter\_queries()}
Each entry will be in one of those lists for Flot to draw.
\end{staticmethoddesc}
\index{get\_case() (webscavator.model.models.Case static method)}

\hypertarget{webscavator.model.models.Case.get_case}{}\begin{staticmethoddesc}{get\_case}{}
Get the current case.
\end{staticmethoddesc}
\index{id (webscavator.model.models.Case attribute)}

\hypertarget{webscavator.model.models.Case.id}{}\begin{memberdesc}{id}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{load\_database() (webscavator.model.models.Case static method)}

\hypertarget{webscavator.model.models.Case.load_database}{}\begin{staticmethoddesc}{load\_database}{dbfile}
Given a database file, connects to the database and binds it to webscavator's session.
\end{staticmethoddesc}
\index{name (webscavator.model.models.Case attribute)}

\hypertarget{webscavator.model.models.Case.name}{}\begin{memberdesc}{name}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\end{classdesc}
\index{Group (class in webscavator.model.models)}

\hypertarget{webscavator.model.models.Group}{}\begin{classdesc}{Group}{name, desc, case, program}~\begin{quote}

Class that stores information about a particular uploaded file.
\begin{description}
\item[\emph{id}    ]
group id

\item[\emph{name}]
group name

\item[\emph{description}]
group description

\item[\emph{csv\_name}]
the filename of the uploaded file

\item[\emph{program}]
the program used to make the file

\item[\emph{case}]
the case object this group belongs to

\item[\emph{entries}]
list of entry objects for this group

\end{description}
\end{quote}

\begin{notice}{note}{Note:}
Most of these forms were created before it was realised that files other than CSV were needed
(such as XML).

\textbf{ToDo}: change \emph{csv\_name} to \emph{file\_name}.
\end{notice}
\index{case (webscavator.model.models.Group attribute)}

\hypertarget{webscavator.model.models.Group.case}{}\begin{memberdesc}{case}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{case\_id (webscavator.model.models.Group attribute)}

\hypertarget{webscavator.model.models.Group.case_id}{}\begin{memberdesc}{case\_id}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{csv\_name (webscavator.model.models.Group attribute)}

\hypertarget{webscavator.model.models.Group.csv_name}{}\begin{memberdesc}{csv\_name}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{description (webscavator.model.models.Group attribute)}

\hypertarget{webscavator.model.models.Group.description}{}\begin{memberdesc}{description}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{getEndDate() (webscavator.model.models.Group method)}

\hypertarget{webscavator.model.models.Group.getEndDate}{}\begin{methoddesc}{getEndDate}{}
Get the ending date of all the group's entries.
\end{methoddesc}
\index{getNumEntries() (webscavator.model.models.Group method)}

\hypertarget{webscavator.model.models.Group.getNumEntries}{}\begin{methoddesc}{getNumEntries}{}
Get amount of entries for this group.
\end{methoddesc}
\index{getStartDate() (webscavator.model.models.Group method)}

\hypertarget{webscavator.model.models.Group.getStartDate}{}\begin{methoddesc}{getStartDate}{}
Get the starting date of all the group's entries.
\end{methoddesc}
\index{id (webscavator.model.models.Group attribute)}

\hypertarget{webscavator.model.models.Group.id}{}\begin{memberdesc}{id}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{name (webscavator.model.models.Group attribute)}

\hypertarget{webscavator.model.models.Group.name}{}\begin{memberdesc}{name}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{program (webscavator.model.models.Group attribute)}

\hypertarget{webscavator.model.models.Group.program}{}\begin{memberdesc}{program}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{program\_icon (webscavator.model.models.Group attribute)}

\hypertarget{webscavator.model.models.Group.program_icon}{}\begin{memberdesc}{program\_icon}
Return the icon of the web history program used to create the file. See 
vizzieweb/convertors/\_\_init\_\_.py for details.
\end{memberdesc}
\index{program\_name (webscavator.model.models.Group attribute)}

\hypertarget{webscavator.model.models.Group.program_name}{}\begin{memberdesc}{program\_name}
Return the full name of the web history program used to create the file. See 
vizzieweb/convertors/\_\_init\_\_.py for details.
\end{memberdesc}
\end{classdesc}
\index{Entry (class in webscavator.model.models)}

\hypertarget{webscavator.model.models.Entry}{}\begin{classdesc}{Entry}{**vars}
Class that stores a particular row in the file.
\begin{description}
\item[\emph{id}]
entry id

\item[\emph{type}]
entry type e.g. URL

\item[\emph{access\_date}]
entry access date

\item[\emph{access\_time}]
entry access time

\item[\emph{modified\_date}]
entry modified date

\item[\emph{modified\_time}]
entry modified time

\item[\emph{url}]
entry url

\item[\emph{filename}]
entry filename on disk

\item[\emph{directory}]
entry folder on disk

\item[\emph{http\_headers}]
entry url http headers

\item[\emph{title}]
entry url title

\item[\emph{deleted}]
whether entry was originally deleted or not

\item[\emph{content\_type}]
type of content, usually only index.dat files store this

\item[\emph{group}]
group object this entry belongs to

\item[\emph{parsedurl}]
url object this entry has

\item[\emph{browser}]
browser object this entry belong to

\end{description}
\index{access\_date (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.access_date}{}\begin{memberdesc}{access\_date}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{access\_time (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.access_time}{}\begin{memberdesc}{access\_time}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{access\_time\_str (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.access_time_str}{}\begin{memberdesc}{access\_time\_str}
A property for access\_time\_str. Returns the date in a normalised format.
\end{memberdesc}
\index{averagePages() (webscavator.model.models.Entry static method)}

\hypertarget{webscavator.model.models.Entry.averagePages}{}\begin{staticmethoddesc}{averagePages}{}
Returns the average number of websites visited in one day, i.e. only http
and http entries.
\end{staticmethoddesc}
\index{browser (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.browser}{}\begin{memberdesc}{browser}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{browser\_id (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.browser_id}{}\begin{memberdesc}{browser\_id}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{browsername (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.browsername}{}\begin{memberdesc}{browsername}
A property for browsername.
\end{memberdesc}
\index{content\_type (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.content_type}{}\begin{memberdesc}{content\_type}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{deleted (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.deleted}{}\begin{memberdesc}{deleted}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{directory (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.directory}{}\begin{memberdesc}{directory}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{filename (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.filename}{}\begin{memberdesc}{filename}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{filesAccessed() (webscavator.model.models.Entry static method)}

\hypertarget{webscavator.model.models.Entry.filesAccessed}{}\begin{staticmethoddesc}{filesAccessed}{}
Returns a file directory tree and the total amount of files accessed. The tree
is a dictionary of drives, each drive letter is the key and the value is another dictionary 
with the keys being file types. For each file type, the value is a tree structure with the
end point being a file name, the number of times the file was accessed and a list of 
access dates.

\begin{notice}{note}{Note:}
This does not allow for Linux etc drives, only Windows one letter drives.

\textbf{ToDo}: re-optimise this query, more things were done making it slow again for 
larger datasets.

\textbf{ToDo}: Allow other operating systems file systems.
\end{notice}
\end{staticmethoddesc}
\index{generateHeatMap() (webscavator.model.models.Entry static method)}

\hypertarget{webscavator.model.models.Entry.generateHeatMap}{}\begin{staticmethoddesc}{generateHeatMap}{}
Returns heatmap things for the overview: the table headers, the heatmap
table and the highest and lowest values (used to calculate heatmap colour).
\end{staticmethoddesc}
\index{group (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.group}{}\begin{memberdesc}{group}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{group\_id (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.group_id}{}\begin{memberdesc}{group\_id}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{http\_headers (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.http_headers}{}\begin{memberdesc}{http\_headers}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{id (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.id}{}\begin{memberdesc}{id}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{modified\_date (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.modified_date}{}\begin{memberdesc}{modified\_date}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{modified\_time (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.modified_time}{}\begin{memberdesc}{modified\_time}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{modified\_time\_str (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.modified_time_str}{}\begin{memberdesc}{modified\_time\_str}
A property for modified\_time\_str. Returns the date in a normalised format.
\end{memberdesc}
\index{peakTime() (webscavator.model.models.Entry static method)}

\hypertarget{webscavator.model.models.Entry.peakTime}{}\begin{staticmethoddesc}{peakTime}{}
Returns the peak time of web browser usage. Similar to the heatmap, although doesn't 
do for each day of the week - sums up each hour and returns the highest.
\end{staticmethoddesc}
\index{timeline\_date (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.timeline_date}{}\begin{memberdesc}{timeline\_date}
A property for timeline\_date. Returns the date in a normalised format for Flot.
\end{memberdesc}
\index{title (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.title}{}\begin{memberdesc}{title}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{type (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.type}{}\begin{memberdesc}{type}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{url (webscavator.model.models.Entry attribute)}

\hypertarget{webscavator.model.models.Entry.url}{}\begin{memberdesc}{url}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\end{classdesc}
\index{URL (class in webscavator.model.models)}

\hypertarget{webscavator.model.models.URL}{}\begin{classdesc}{URL}{url=None}
Class that stores a URL for an entry divided up into its different parts.
\begin{description}
\item[\emph{entry\_id}]
url id

\item[\emph{scheme}]
url scheme

\item[\emph{netloc}]
url network location

\item[\emph{path}]
url path

\item[\emph{params}]
url params

\item[\emph{query}]
url query strings

\item[\emph{fragment}]
url fragment

\item[\emph{username}]
url username

\item[\emph{password}]
url password

\item[\emph{hostname}]
url hostname

\item[\emph{port}]
url port

\item[\emph{domain}]
normalised hostname i.e without the www

\item[\emph{search}]
the search engine string (if any)

\item[\emph{entry}]
entry object. one-to-one join.

\end{description}
\index{asDict() (webscavator.model.models.URL method)}

\hypertarget{webscavator.model.models.URL.asDict}{}\begin{methoddesc}{asDict}{}
Used for optimising adding URLs to database when converting files.
\end{methoddesc}
\index{domain (webscavator.model.models.URL attribute)}

\hypertarget{webscavator.model.models.URL.domain}{}\begin{memberdesc}{domain}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{entry (webscavator.model.models.URL attribute)}

\hypertarget{webscavator.model.models.URL.entry}{}\begin{memberdesc}{entry}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{entry\_id (webscavator.model.models.URL attribute)}

\hypertarget{webscavator.model.models.URL.entry_id}{}\begin{memberdesc}{entry\_id}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{fragment (webscavator.model.models.URL attribute)}

\hypertarget{webscavator.model.models.URL.fragment}{}\begin{memberdesc}{fragment}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{getTop() (webscavator.model.models.URL static method)}

\hypertarget{webscavator.model.models.URL.getTop}{}\begin{staticmethoddesc}{getTop}{num=100, highlight\_funcs=, {[}{]}, remove\_funcs=, {[}{]}}
Get the top {[}amount{]} filtered URLS for a case. This has been optimised as one 
query with a subquery.
\end{staticmethoddesc}
\index{hostname (webscavator.model.models.URL attribute)}

\hypertarget{webscavator.model.models.URL.hostname}{}\begin{memberdesc}{hostname}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{netloc (webscavator.model.models.URL attribute)}

\hypertarget{webscavator.model.models.URL.netloc}{}\begin{memberdesc}{netloc}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{params (webscavator.model.models.URL attribute)}

\hypertarget{webscavator.model.models.URL.params}{}\begin{memberdesc}{params}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{password (webscavator.model.models.URL attribute)}

\hypertarget{webscavator.model.models.URL.password}{}\begin{memberdesc}{password}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{path (webscavator.model.models.URL attribute)}

\hypertarget{webscavator.model.models.URL.path}{}\begin{memberdesc}{path}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{port (webscavator.model.models.URL attribute)}

\hypertarget{webscavator.model.models.URL.port}{}\begin{memberdesc}{port}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{query (webscavator.model.models.URL attribute)}

\hypertarget{webscavator.model.models.URL.query}{}\begin{memberdesc}{query}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{scheme (webscavator.model.models.URL attribute)}

\hypertarget{webscavator.model.models.URL.scheme}{}\begin{memberdesc}{scheme}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{search (webscavator.model.models.URL attribute)}

\hypertarget{webscavator.model.models.URL.search}{}\begin{memberdesc}{search}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{setDomain() (webscavator.model.models.URL method)}

\hypertarget{webscavator.model.models.URL.setDomain}{}\begin{methoddesc}{setDomain}{}
Removes www from front of any hostnames to normalise the hostnames and 
then tries to remove subdomains by working backwards to find the domain.
\end{methoddesc}
\index{setDomain\_manual() (webscavator.model.models.URL static method)}

\hypertarget{webscavator.model.models.URL.setDomain_manual}{}\begin{staticmethoddesc}{setDomain\_manual}{group}
Manually set the domain names. Used in the optimised adding of URLs which bypasses 
creating URL objects using \emph{\_\_init\_\_()}
\end{staticmethoddesc}
\index{urlstrip() (webscavator.model.models.URL method)}

\hypertarget{webscavator.model.models.URL.urlstrip}{}\begin{methoddesc}{urlstrip}{url}
Some urls from IE appear like {[}username{]}@{[}url{]}. urlstrip() gets rid of the 
{[}username{]}@ bit. Returns the shortened URL
\end{methoddesc}
\index{username (webscavator.model.models.URL attribute)}

\hypertarget{webscavator.model.models.URL.username}{}\begin{memberdesc}{username}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\end{classdesc}
\index{Filter (class in webscavator.model.models)}

\hypertarget{webscavator.model.models.Filter}{}\begin{classdesc}{Filter}{label, text, fillColor='\#33A1C9'}
Class that stores a filter object.
\begin{description}
\item[\emph{id}]
filter id

\item[\emph{fillcolor}]
the color of flot's markers

\item[\emph{label}]
the name of the filter

\item[\emph{text}]
the long name of the filter, what the user sees

\item[\emph{query}]
pickled Filter object which stores the filter parts see model/filters.py

\end{description}
\index{fillColor (webscavator.model.models.Filter attribute)}

\hypertarget{webscavator.model.models.Filter.fillColor}{}\begin{memberdesc}{fillColor}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{id (webscavator.model.models.Filter attribute)}

\hypertarget{webscavator.model.models.Filter.id}{}\begin{memberdesc}{id}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{label (webscavator.model.models.Filter attribute)}

\hypertarget{webscavator.model.models.Filter.label}{}\begin{memberdesc}{label}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{onlineSearches() (webscavator.model.models.Filter static method)}

\hypertarget{webscavator.model.models.Filter.onlineSearches}{}\begin{staticmethoddesc}{onlineSearches}{engine, highlight\_funcs=, {[}{]}, remove\_funcs=, {[}{]}, num=20}
Given a search engine, amount and filters, returns a word cloud dictionary of search terms.
The keys are the terms and the values are a (ratio, search phrases term was in, 
length of search phrases) tuple. Also returns total amount of terms, total number of unique 
terms and the smallest ratio (used to make the sizes of the words relative to smallest).
\end{staticmethoddesc}
\index{query (webscavator.model.models.Filter attribute)}

\hypertarget{webscavator.model.models.Filter.query}{}\begin{memberdesc}{query}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{text (webscavator.model.models.Filter attribute)}

\hypertarget{webscavator.model.models.Filter.text}{}\begin{memberdesc}{text}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\end{classdesc}
\index{SearchTerms (class in webscavator.model.models)}

\hypertarget{webscavator.model.models.SearchTerms}{}\begin{classdesc}{SearchTerms}{term, engine, engine\_long}
Class that stores a search term.
\begin{description}
\item[\emph{id}]
search term id

\item[\emph{term}]
the term

\item[\emph{occurrence}]
number of times term has appeared in searches

\item[\emph{engine}]
what search engine this term appeared in

\item[\emph{engine\_long}]
full name of search engine

\item[\emph{entries}]
list of entries search term belongs to

\end{description}
\index{engine (webscavator.model.models.SearchTerms attribute)}

\hypertarget{webscavator.model.models.SearchTerms.engine}{}\begin{memberdesc}{engine}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{engine\_long (webscavator.model.models.SearchTerms attribute)}

\hypertarget{webscavator.model.models.SearchTerms.engine_long}{}\begin{memberdesc}{engine\_long}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{entries (webscavator.model.models.SearchTerms attribute)}

\hypertarget{webscavator.model.models.SearchTerms.entries}{}\begin{memberdesc}{entries}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{getTerms() (webscavator.model.models.SearchTerms static method)}

\hypertarget{webscavator.model.models.SearchTerms.getTerms}{}\begin{staticmethoddesc}{getTerms}{query}
Given the query part of a url, extracts the serach terms or phrases (those surrounded
by quotes). Returns the search string and a list of terms in that string.
\end{staticmethoddesc}
\index{id (webscavator.model.models.SearchTerms attribute)}

\hypertarget{webscavator.model.models.SearchTerms.id}{}\begin{memberdesc}{id}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{occurrence (webscavator.model.models.SearchTerms attribute)}

\hypertarget{webscavator.model.models.SearchTerms.occurrence}{}\begin{memberdesc}{occurrence}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\index{term (webscavator.model.models.SearchTerms attribute)}

\hypertarget{webscavator.model.models.SearchTerms.term}{}\begin{memberdesc}{term}
Public-facing descriptor, placed in the mapped class dictionary.
\end{memberdesc}
\end{classdesc}
\index{get\_plotable() (in module webscavator.model.models)}

\hypertarget{webscavator.model.models.get_plotable}{}\begin{funcdesc}{get\_plotable}{d, t, u, bn, bv, bs, p, ti}
Returns (date, time, URL, browser name, browser version, browser source, program name, title)
in a format Flot (the JavaScript timeline library) will understand. 
Only (date, time) needs to be sent in order
for the graph to be displayed properly. The others are used for hover over and clickable text.

\begin{notice}{note}{Note:}
Currently this function uses a hack to get British Summer Time dates to be displayed
properly as GMT in Flot by adding an hour on to any dates after March 28th 2010.

\textbf{ToDo}: Fix this urgently!!
\end{notice}
\end{funcdesc}
\index{getFilter() (in module webscavator.model.models)}

\hypertarget{webscavator.model.models.getFilter}{}\begin{funcdesc}{getFilter}{highlight\_funcs=, {[}{]}, remove\_funcs=, {[}{]}}
Get the right filter. This is used to filter domain names and search terms correctly.
\emph{Case.filter\_queries} is called, and if \emph{highlight\_funcs} != {[}{]} then return
the highlighted query, otherwise return the non-highlighted query.
\end{funcdesc}

\resetcurrentobjects
\hypertarget{--doc-filters}{}

\subsection{Filters}
\index{webscavator.model.filters (module)}
\hypertarget{module-webscavator.model.filters}{}
\declaremodule[webscavator.model.filters]{}{webscavator.model.filters}
\modulesynopsis{}

\subsubsection{Filters}

\emph{FilterQuery} objects save the filter details and are stored pickled in the \emph{Filter} class as
\emph{Filter.query} in \hyperlink{--doc-models}{\emph{Database Models}}.
\index{FilterQuery (class in webscavator.model.filters)}

\hypertarget{webscavator.model.filters.FilterQuery}{}\begin{classdesc}{FilterQuery}{}
Stores the tables, attributes, operations and values of a query, e.g.

\begin{Verbatim}[commandchars=@\[\]]
params @PYGbe[=] (Entry, title, Is, @PYGaB[']@PYGaB[Test]@PYGaB['])
\end{Verbatim}

which equates to \emph{WHERE Entry.title = `Test'} in SQL.

\emph{FilterQuery} objects get stored inside a \emph{Filter} object in \hyperlink{--doc-models}{\emph{Database Models}}. The
object stored inside the \emph{Filter} object gets pickled thereby preserving the
filter information.
\index{add\_element() (webscavator.model.filters.FilterQuery method)}

\hypertarget{webscavator.model.filters.FilterQuery.add_element}{}\begin{methoddesc}{add\_element}{cls, attr, func, val, val\_list}
Add a new filter line to the \emph{FilterQuery} object \emph{params} list 
attribute.
\end{methoddesc}
\index{query() (webscavator.model.filters.FilterQuery method)}

\hypertarget{webscavator.model.filters.FilterQuery.query}{}\begin{methoddesc}{query}{}
Called by \emph{Case.filter\_queries()} in \hyperlink{--doc-models}{\emph{Database Models}} to construct the filter
clause. Returns an ANDed list of filters e.g. \emph{Entry.title = ``test'' AND
Entry.url \textless{}\textgreater{} ``http://example.org''}
\end{methoddesc}
\end{classdesc}
\index{regexp() (in module webscavator.model.filters)}

\hypertarget{webscavator.model.filters.regexp}{}\begin{funcdesc}{regexp}{expr, item}
Enables regular expressions for filter queries.
\end{funcdesc}
\index{webscavator.model (module)}
\hypertarget{module-webscavator.model}{}
\declaremodule[webscavator.model]{}{webscavator.model}
\modulesynopsis{}

\subsection{Models}

All the Python code to do with the database is kept here. This uses the 
\href{http://www.sqlalchemy.org/}{SQLAlchemy} ORM library. The underlying database
is sqlite, but could very easily be modified.

\resetcurrentobjects
\hypertarget{--doc-utilities}{}

\section{Utility functions}

Package Contents:

\resetcurrentobjects
\hypertarget{--doc-utils}{}

\subsection{Utils}
\index{webscavator.utils.utils (module)}
\hypertarget{module-webscavator.utils.utils}{}
\declaremodule[webscavator.utils.utils]{}{webscavator.utils.utils}
\modulesynopsis{}
Useful variables and methods. Includes all the database connection functions and access to the 
configuration file.


\subsubsection{Variables}
\begin{description}
\item[\emph{ROOT\_DIR}]
the root directory of Webscavator.

\item[\emph{CASE\_FILE\_DIR}]
where case files are kept.

\item[\emph{CONFIG\_PATH}]
where the config file is kept.

\item[\emph{FILE\_TYPES}]
dictionary of file extensions and what type of file they are. Used in 
displaying file accesses in the `files' tab.

\item[\emph{session}]
the sqlite session. Used to access the database. Useful methods include  
session.add(obj){}`, \emph{session.flush()} and \emph{session.commit()}.

\item[\emph{config}]
the config parser. To get an option do \emph{config{[}section{]}{[}option{]}}

\end{description}


\subsubsection{Functions}
\index{bind() (in module webscavator.utils.utils)}

\hypertarget{webscavator.utils.utils.bind}{}\begin{funcdesc}{bind}{db}
This binds the database to the current session.
\end{funcdesc}
\index{checkDebugging() (in module webscavator.utils.utils)}

\hypertarget{webscavator.utils.utils.checkDebugging}{}\begin{funcdesc}{checkDebugging}{testing}
If debug is set to \emph{True} in the config file, a default database is loaded called \emph{debug.db}. 
This is so that every time webscavator is restarted, there is a database pre-loaded. 
The Python web server automatically restarts when it detects a change to the code, 
so when debugging webscavator lots of restarts will happen.
\end{funcdesc}
\index{connect() (in module webscavator.utils.utils)}

\hypertarget{webscavator.utils.utils.connect}{}\begin{funcdesc}{connect}{dbfile}
Given a database file, create an SQLAlchemy database engine which connects to the database.
\end{funcdesc}
\index{getCases() (in module webscavator.utils.utils)}

\hypertarget{webscavator.utils.utils.getCases}{}\begin{funcdesc}{getCases}{}
Gets the case names (.db files) stored in the case file directory.
\end{funcdesc}
\index{getLists() (in module webscavator.utils.utils)}

\hypertarget{webscavator.utils.utils.getLists}{}\begin{funcdesc}{getLists}{}
Gets the list names (.txt files) stored in the case lists directory.
\end{funcdesc}
\index{init\_database() (in module webscavator.utils.utils)}

\hypertarget{webscavator.utils.utils.init_database}{}\begin{funcdesc}{init\_database}{db}
Initialises the database by creating all the tables in webscavator.models.models.py.
\end{funcdesc}
\index{multidict\_to\_dict() (in module webscavator.utils.utils)}

\hypertarget{webscavator.utils.utils.multidict_to_dict}{}\begin{funcdesc}{multidict\_to\_dict}{md}
Turns a Werkzeug multidict into a dictionary with lists in entries which have 
more than one value.
\end{funcdesc}
\index{setup() (in module webscavator.utils.utils)}

\hypertarget{webscavator.utils.utils.setup}{}\begin{funcdesc}{setup}{testing=False}
This is run when webscavator is started in \hyperlink{--doc-launch}{\emph{launch.py}}.
Finds the config file and loads it into the global variable
config using \emph{ConfigParser()}. Then runs \emph{checkDebugging(testing)}
with the config option for testing.
\end{funcdesc}
\index{webscavator.utils (module)}
\hypertarget{module-webscavator.utils}{}
\declaremodule[webscavator.utils]{}{webscavator.utils}
\modulesynopsis{}

\subsection{Utilities}

All utility libraries should go in here.

\resetcurrentobjects
\hypertarget{--doc-testing}{}

\section{Testing}

Package Contents:

\resetcurrentobjects
\hypertarget{--doc-test_utils}{}

\subsection{Testing Utilities}
\index{webscavator.test.utils (module)}
\hypertarget{module-webscavator.test.utils}{}
\declaremodule[webscavator.test.utils]{}{webscavator.test.utils}
\modulesynopsis{}
Some utilities for testing.
\index{FakeFileUpload (class in webscavator.test.utils)}

\hypertarget{webscavator.test.utils.FakeFileUpload}{}\begin{classdesc}{FakeFileUpload}{filename, content\_type, location}
A fake File Upload to mimic uploading an actual file.
\end{classdesc}

\resetcurrentobjects
\hypertarget{--doc-functional}{}

\subsection{Functional Testing}

Package Contents:

\resetcurrentobjects
\hypertarget{--doc-test_caseController}{}

\subsubsection{Case Controller Testing}
\index{webscavator.test.functionaltests.test\_caseController (module)}
\hypertarget{module-webscavator.test.functionaltests.test_caseController}{}
\declaremodule[webscavator.test.functionaltests.testcaseController]{}{webscavator.test.functionaltests.test\_caseController}
\modulesynopsis{}
\resetcurrentobjects
\hypertarget{--doc-test_generalController}{}

\subsubsection{General Controller Testing}
\index{webscavator.test.functionaltests.test\_generalController (module)}
\hypertarget{module-webscavator.test.functionaltests.test_generalController}{}
\declaremodule[webscavator.test.functionaltests.testgeneralController]{}{webscavator.test.functionaltests.test\_generalController}
\modulesynopsis{}
\resetcurrentobjects
\hypertarget{--doc-test_visualController}{}

\subsubsection{Visual Controller Testing}
\index{webscavator.test.functionaltests.test\_visualController (module)}
\hypertarget{module-webscavator.test.functionaltests.test_visualController}{}
\declaremodule[webscavator.test.functionaltests.testvisualController]{}{webscavator.test.functionaltests.test\_visualController}
\modulesynopsis{}\index{webscavator.test.functionaltests (module)}
\hypertarget{module-webscavator.test.functionaltests}{}
\declaremodule[webscavator.test.functionaltests]{}{webscavator.test.functionaltests}
\modulesynopsis{}
\resetcurrentobjects
\hypertarget{--doc-unit}{}

\subsection{Unit Testing}

Package Contents:

\resetcurrentobjects
\hypertarget{--doc-test_forms}{}

\subsubsection{Forms Testing}
\index{webscavator.test.unittests.test\_forms (module)}
\hypertarget{module-webscavator.test.unittests.test_forms}{}
\declaremodule[webscavator.test.unittests.testforms]{}{webscavator.test.unittests.test\_forms}
\modulesynopsis{}
\resetcurrentobjects
\hypertarget{--doc-test_validators}{}

\subsubsection{Validator Testing}
\index{webscavator.test.unittests.test\_validators (module)}
\hypertarget{module-webscavator.test.unittests.test_validators}{}
\declaremodule[webscavator.test.unittests.testvalidators]{}{webscavator.test.unittests.test\_validators}
\modulesynopsis{}
\resetcurrentobjects
\hypertarget{--doc-test_models}{}

\subsubsection{Model Testing}
\index{webscavator.test.unittests.test\_models (module)}
\hypertarget{module-webscavator.test.unittests.test_models}{}
\declaremodule[webscavator.test.unittests.testmodels]{}{webscavator.test.unittests.test\_models}
\modulesynopsis{}\index{webscavator.test.unittests (module)}
\hypertarget{module-webscavator.test.unittests}{}
\declaremodule[webscavator.test.unittests]{}{webscavator.test.unittests}
\modulesynopsis{}\index{webscavator.test (module)}
\hypertarget{module-webscavator.test}{}
\declaremodule[webscavator.test]{}{webscavator.test}
\modulesynopsis{}
This is where all the unit and functional tests are kept.
\index{runTests() (in module webscavator.test)}

\hypertarget{webscavator.test.runTests}{}\begin{funcdesc}{runTests}{unittests=True, functionaltests=True}
Tests are run from \hyperlink{--doc-launch}{\emph{launch.py}} by typing in the command line:

\begin{Verbatim}[commandchars=@\[\]]
python launch.py runtests functional=True unit=True
\end{Verbatim}
\end{funcdesc}


\chapter{Indices and tables}
\begin{itemize}
\item {} 
\emph{Index}

\item {} 
\emph{Module Index}

\item {} 
\emph{Search Page}

\end{itemize}


\renewcommand{\indexname}{Module Index}
\printmodindex
\renewcommand{\indexname}{Index}
\printindex
\end{document}
